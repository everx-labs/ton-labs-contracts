/*
    This file is part of TON OS.

    TON OS is free software: you can redistribute it and/or modify 
    it under the terms of the Apache License 2.0 (http://www.apache.org/licenses/)

    Copyright 2019-2023 (c) EverX
*/

pragma ton-solidity ^ 0.66.0;
pragma ignoreIntOverflow;
pragma AbiHeader time;
import "IConfig.tsol";
import "IElector.tsol";
import "IValidator.tsol";
import "Common.tsol";

// Config parameters used in the contract:
//  0  Configuration smart-contract address
//  1  Elector smart-contract address
// 13  Complaint prices
// 15  Election parameters
// 16  Validator count
// 17  Validator stake parameters
// 34  Current validator set
// 36  Next validator set

contract Elector is IElector {

    uint32 constant VERSION_MAJOR = 0;
    uint32 constant VERSION_MINOR = 1;
    uint256 constant PRECISION = 1e18;
    uint constant ERROR_ELECT = 123;
    uint constant ERROR_C4 = 124;

    struct Elect {
        uint32 elect_at;
        uint32 elect_close;
        varUint16 min_stake;
        varUint16 total_stake;
        mapping(uint256 => Member) members;
        bool failed;
        bool finished;
        bool open;
    }

    struct Member {
        varUint16 stake;
        uint32 time;
        uint32 max_factor;
        uint256 addr;
        uint256 adnl_addr;
    }

    struct PastElection {
        uint32 unfreeze_at;
        uint32 stake_held;
        uint256 vset_hash;
        mapping(uint256 => Frozen) frozen_dict;
        varUint16 total_stake;
        varUint16 bonuses;
        mapping(uint256 => ComplaintStatus) complaints;
    }

    struct Chain {
        mapping(uint32 =>PastElection) past_elections;
        Elect election;
        uint32 active_id;
        uint256 active_hash;
        uint64 vtors_weight;
    }

    struct Frozen {
        uint256 addr;
        uint64 weight;
        varUint16 stake;
        bool banned;
    }

    struct ComplaintStatus {
        uint8 tag; // = 0x2d
        TvmCell complaint;
        mapping(uint16 => uint32) voters;
        uint256 vset_id;
        int64 weight_remaining;
    }

    mapping(int32 => Chain) m_chains;

    mapping(uint256 => varUint16) m_credits;

    varUint16 m_grams;

    constructor() public {
        tvm.setPubkey(0);
        Chain startChain;
        m_chains[0] = startChain;
    }

    function get_validator_conf() internal pure inline returns (uint32, uint32, uint32, uint32) {
        (uint32 elect_for, uint32 elect_begin_before,
          uint32 elect_end_before, uint32 stake_held, /* bool */) = tvm.configParam(15);
        return (elect_for, elect_begin_before, elect_end_before, stake_held);
    }

    function get_current_vset(int32 chainId) internal pure returns (Common.ValidatorSet) {
//        TvmCell info;
//        bool f;
//        (info, f) = tvm.rawConfigParam(35);
//        if (!f) {
//            (info, /* bool */) = tvm.rawConfigParam(34);
//        }
//        Common.ValidatorSet vset = info.toSlice().decode(Common.ValidatorSet);
//        require(vset.tag == 0x12, 40);
//        return (info, vset.total_weight, vset.vdict);
        optional(Common.ValidatorSets) may_be_vsets = Common.getValidatorSetsByChain(chainId);

        Common.ValidatorSet info;
        if (may_be_vsets.hasValue()) {
            Common.ValidatorSets vsets = may_be_vsets.get();
            if (vsets.slashed.hasValue()) {
                info = vsets.slashed.get();
            }
            if (vsets.current.hasValue()) {
                info = vsets.current.get();
            }
        }
        return info;

//        bool f;
//
//        (info, f) = tvm.rawConfigParam(35);
//        if (!f) {
//            (info, /* bool */) = tvm.rawConfigParam(34);
//        }
//        Common.ValidatorSet vset = info.toSlice().decode(Common.ValidatorSet);
//        require(vset.tag == 0x12, 40);
//        return (info, vset.total_weight, vset.vdict);
    }

    function send_message_back(address addr, uint32 ans_tag, uint64 query_id,
                               uint32 body, uint128 amount, uint8 mode) internal pure {
        TvmBuilder b;
        b.storeUnsigned(0x18, 6);
        b.store(addr);
        b.storeTons(amount);
        b.storeUnsigned(0, 1 + 4 + 4 + 64 + 32 + 1 + 1);
        b.store(ans_tag);
        b.store(query_id);
        b.storeUnsigned(body, 32);
        tvm.sendrawmsg(b.toCell(), mode);
    }

    function return_stake(uint64 query_id, uint32 reason) internal pure {
        IValidator(msg.sender).return_stake{value: 0, flag: 64}(query_id, reason);
    }

    function send_confirmation(uint64 query_id, uint32 comment) internal pure {
        IValidator(msg.sender).confirmation{value: 1 ever, flag: 2}(query_id, comment);
    }

    function send_validator_set_to_config(
        uint256 config_addr,
        TvmCell vset,
        uint64 query_id,
        int32 chainId
    ) internal pure inline {
        address addr = address.makeAddrStd(-1, config_addr);
        IConfig(addr).set_next_validator_set{value: (1 << 30), flag: 1}(query_id, vset, chainId);
    }

    function credit_to(uint256 addr, uint128 amount) internal inline {
        m_credits[addr] += varUint16(amount);
        //emit CreditToEvent(addr, amount);
    }

    function process_new_stake(
        uint64 query_id,
        uint256 validator_pubkey,
        uint32 stake_at,
        uint32 max_factor,
        uint256 adnl_addr,
        bytes signature,
        int32 chainId
    ) override public functionID(0x4e73744b) internalMsg {
        (int8 src_wc, uint256 src_addr) = msg.sender.unpack();
        if (!m_chains[chainId].election.open || src_wc != -1) {
            // no elections active, or source is not in masterchain
            // bounce message
            return return_stake(query_id, 0);
        }
        TvmBuilder data;
        data.store(uint32(0x654c5074), stake_at, max_factor, src_addr, adnl_addr);
        if (!tvm.checkSign(data.toSlice(), signature.toSlice(), validator_pubkey)) {
            // incorrect signature, return stake
            return return_stake(query_id, 1);
        }
        if (max_factor < 0x10000) {
            // factor must be >= 1. = 65536/65536
            return return_stake(query_id, 6);
        }
        uint128 total_stake = m_chains[chainId].election.total_stake;
        // deduct GR$1 for sending confirmation
        uint256 msg_value = msg.value - 1 ever;
        if ((msg_value << 12) < total_stake) {
            // stake smaller than 1/4096 of the total accumulated stakes, return
            return return_stake(query_id, 2);
        }
        // (provisionally) increase total stake
        total_stake += uint128(msg_value);
        if (stake_at != m_chains[chainId].election.elect_at) {
            // stake for some other elections, return
            return return_stake(query_id, 3);
        }
        if (m_chains[chainId].election.finished) {
            // elections already finished, return stake
            return return_stake(query_id, 0);
        }
        optional(Member) m = m_chains[chainId].election.members.fetch(validator_pubkey);
        bool found = false;
        if (m.hasValue()) {
            // log("merging stakes");
            Member mem = m.get();
            // entry found, merge stakes
            msg_value += uint256(mem.stake);
            found = (src_addr != mem.addr);
        }
        if (found) {
            // can make stakes for a public key from one address only
            return return_stake(query_id, 4);
        }
        if (msg_value < uint256(m_chains[chainId].election.min_stake)) {
            // stake too small, return it
            return return_stake(query_id, 5);
        }
        (, uint128 max_stake, , , ) = tvm.configParam(17);
        if (msg_value > max_stake) {
            // stake exceeds max_stake config parameter, return it
            return return_stake(query_id, 7);
        }
        require(msg_value != 0, 44);
        tvm.accept();
        // store stake in the dictionary
        m_chains[chainId].election.members[validator_pubkey] =
            Member(varUint16(msg_value), now, max_factor, src_addr, adnl_addr);
        m_chains[chainId].election.failed = false;
        m_chains[chainId].election.finished = false;
        m_chains[chainId].election.total_stake = varUint16(total_stake);
        // return confirmation message
        if (query_id != 0) {
            return send_confirmation(query_id, 0);
        }
    }

    function unfreeze_without_bonuses(mapping(uint256 => Frozen) freeze_dict,
                                      uint128 tot_stakes) internal
            returns (uint128) {
        uint128 total = 0;
        uint128 recovered = 0;
        optional(uint256, Frozen) f = freeze_dict.min();
        while (f.hasValue()) {
            (uint256 pubkey, Frozen frozen) = f.get();
            if (frozen.banned) {
                recovered += uint128(frozen.stake);
            } else {
                credit_to(frozen.addr, frozen.stake);
                total += uint128(frozen.stake);
            }
            f = freeze_dict.next(pubkey);
        }
        require(total == tot_stakes, 59);
        return recovered;
    }

    function unfreeze_with_bonuses(
        mapping(uint256 => Frozen) freeze_dict,
        uint128 tot_stakes,
        uint128 tot_bonuses
    ) internal returns (uint128) {
        uint128 total = 0;
        uint128 recovered = 0;
        uint128 returned_bonuses = 0;

        optional(uint256, Frozen) f = freeze_dict.min();
        while (f.hasValue()) {


            (uint256 pubkey, Frozen frozen) = f.get();

            if (frozen.banned) {
                recovered += uint128(frozen.stake);
            } else {
                (uint128 bonus, ) = math.muldivmod(tot_bonuses, uint128(frozen.stake), tot_stakes);
                returned_bonuses += bonus;
                credit_to(frozen.addr, frozen.stake + bonus);
                total += uint128(frozen.stake);
            }
            f = freeze_dict.next(pubkey);
        }
        require((total == tot_stakes) && (returned_bonuses <= tot_bonuses), 59);
        return recovered + tot_bonuses - returned_bonuses;
    }

    function stakes_sum(mapping(uint256 => Frozen) frozen_dict) internal pure returns (uint128) {
        uint128 total = 0;
        optional(uint256, Frozen) f = frozen_dict.min();
        while (f.hasValue()) {
            (uint256 pubkey, Frozen frozen) = f.get();
            total += uint128(frozen.stake);
            f = frozen_dict.next(pubkey);
        }
        return total;
    }

    function unfreeze_all(uint32 elect_id, int32 chainId) internal returns (uint128) {

        optional(PastElection) p = m_chains[chainId].past_elections.fetch(elect_id);
        if (!p.hasValue()) {
            return 0;
        }
        delete m_chains[chainId].past_elections[elect_id];
        PastElection past = p.get();
        uint128 tot_stakes = past.total_stake;
        // tot_stakes = stakes_sum(p.frozen_dict); ;; TEMP BUGFIX
        if (past.bonuses > 0) {
            return unfreeze_with_bonuses(past.frozen_dict, tot_stakes, past.bonuses);
        }
        return unfreeze_without_bonuses(past.frozen_dict, tot_stakes);
    }

    function config_set_confirmed(uint64 query_id, bool ok, int32 chainId) internal {
        (int8 src_wc, uint256 src_addr) = msg.sender.unpack();
        (TvmCell cfg0, /* bool */) = tvm.rawConfigParam(0);
        uint256 config_addr = cfg0.toSlice().loadUnsigned(256);

        Elect election = m_chains[chainId].election;

        if (src_wc != -1 || src_addr != config_addr || !election.open) {
            // not from config smc, somebody's joke?
            // or no elections active (or just completed)
            return;
        }
        if (election.elect_at != query_id || !election.finished) {
            // not these elections, or elections not finished yet
            return;
        }
        tvm.accept();
        if (!ok) {
            // cancel elections, return stakes
            m_grams += varUint16(unfreeze_all(m_chains[chainId].election.elect_at,chainId));
            m_chains[chainId].election.open = false;
        }
        // ... do not remove elect until we see this set as the next elected validator set
    }

    function config_set_confirmed_ok(uint64 query_id, int32 chainId) override public
            functionID(0xee764f4b) internalMsg {
        config_set_confirmed(query_id, true, chainId);
    }

    function config_set_confirmed_err(uint64 query_id, int32 chainId) override public
            functionID(0xee764f6f) internalMsg {
        config_set_confirmed(query_id, false, chainId);
    }

    function config_slash_confirmed_ok(uint64 query_id) override public
            functionID(0xee764f4c) internalMsg {
    }

    function config_slash_confirmed_err(uint64 query_id) override public
            functionID(0xee764f70) internalMsg {
    }

    function grant() override public functionID(0x4772616e) internalMsg {
        m_grams += varUint16(msg.value);
    }

    function take_change() override public internalMsg {
    }


    function receiveBonuses(int32 chainId) override external internalMsg {
        if  (m_chains.exists(chainId)) {
            ( mapping(uint32 => PastElection) past_elections, ,uint32 activeId,,) = m_chains[chainId].unpack();

            if (past_elections.exists(activeId)) {
                m_chains[chainId].past_elections[activeId].bonuses += varUint16(msg.value);
            }
        }
    }

    function process_simple_transfer() internal {
        msg.sender.transfer({value: 0, flag: 64});
    }

//    function process_simple_transfer() internal {
//        (int8 src_wc, uint256 src_addr) = msg.sender.unpack();
//        if (src_addr != 0 || src_wc != -1 || m_active_id == 0) {
//            // simple transfer to us (credit "nobody's" account)
//            // (or no known active validator set)
//            msg.sender.transfer({value: 0, flag: 64});
//            return;
//        }
//        // zero source address -1:00..00 (collecting validator fees)
//        optional(PastElection) p = m_past_elections.fetch(m_active_id);
//        if (!p.hasValue()) {
//            // active validator set not found (?)
//            m_grams += varUint16(msg.value);
//        } else {
//            PastElection past = p.get();
//            // credit active validator set bonuses
//            past.bonuses += varUint16(msg.value);
//            m_past_elections[m_active_id] = past;
//        }
//    }

    function recover_stake(uint64 query_id)
        override
        public
        functionID(0x47657424)
        internalMsg
    {
        (int8 src_wc, uint256 src_addr) = msg.sender.unpack();
        if (src_wc != -1) {
            // not from masterchain, return error
            send_message_back(msg.sender, 0xfffffffe, query_id, 0x47657424, 0, 64);
            return;
        }
        // need to check banned
        optional(uint128) amount = m_credits.fetch(src_addr);
        if (!amount.hasValue()) {

            // no credit for sender, return error
            send_message_back(msg.sender, 0xfffffffe, query_id, 0x47657424, 0, 64);
            return;
        }
        delete m_credits[src_addr];
        // send amount to sender in a new message
        IValidator(msg.sender).receive_stake_back{value: amount.get(), flag: 64}(query_id);
    }

    function recover_stake_gracefully(
        uint64 query_id,
        uint32 elect_id,
        int32 chainId
    )
    override
    public
    functionID(0x47657425)
    internalMsg
    {
        (int8 src_wc, uint256 src_addr) = msg.sender.unpack();
        if (src_wc != -1) {
            // not from masterchain, return error
            send_message_back(msg.sender, 0xfffffffe, query_id, 0x47657425, 0, 64);
            return;
        }
        optional(uint128) amount = m_credits.fetch(src_addr);
        if (!amount.hasValue() ) {
            optional(Chain) chain = m_chains.fetch(chainId);

            if (chain.hasValue()) {
                optional(PastElection) p = chain.get().past_elections.fetch(elect_id);
                if (!p.hasValue()) {
                    send_message_back(msg.sender, 0xfffffffe, query_id, 0x47657425, 0, 64);
                    return;
                }
                PastElection past = p.get();
                send_message_back(msg.sender, 0xfffffffd, query_id, past.unfreeze_at, 0, 64);
                return;
            }

        }
        delete m_credits[src_addr];
        // send amount to sender in a new message
        IValidator(msg.sender).receive_stake_back{value: amount.get(), flag: 64}(query_id);
    }

    function get_elect_at(uint64 query_id, int32 chainId) override public
            functionID(0x47657426) internalMsg {
        (int8 src_wc, /*uint256 src_addr*/) = msg.sender.unpack();
        if (src_wc != -1) {
            // not from masterchain, return error
            send_message_back(msg.sender, 0xfffffffc, query_id, 0x47657426, 0, 64);
            return;
        }
        IValidator(msg.sender).receive_elect_at{
                value: 0,
                flag: 64
        }(query_id, m_chains[chainId].election.open, m_chains[chainId].election.elect_at);
    }

    function postpone_elections(uint16 result) inline internal pure returns (bool) {
        tvm.hexdump(result);
        return false;
    }

    struct List {
        uint128 stake;
        uint32 max_f;
        uint256 pubkey;
        uint256 adnl_addr;
        optional(List) tail;
    }

    struct EdgeStake {
        uint256 stake;
        uint16 id;
    }

    struct StakeAndFactor {
        uint128 stake;
        uint32 max_f;
    }

    // computes the total stake out of the first n entries of list l
    function compute_total_stake(optional(List) l, uint16 n, uint128 m_stake) internal pure inline
            returns (uint128) {

        uint128 tot_stake = 0;
        repeat(n) {
            List h = l.get();
            tot_stake += math.min(h.stake, ((h.max_f) * m_stake) >> 16);
            l = h.tail;
        }
        return tot_stake;
    }

    struct Key {
        uint128 stake;
        int32 time;
        uint256 pubkey;
    }

    struct Value {
        uint32 max_f;
        uint256 addr;
        uint256 adnl_addr;
    }

    function try_elect(
        uint128 min_stake,
        uint128 max_stake,
        uint128 min_total_stake,
        uint32 max_stake_factor,
        int32 chainId
    ) internal inline
            returns (mapping(uint16 => TvmSlice), uint64, mapping(uint256 => Frozen), uint128, uint16) {
        (TvmCell cfg16, /* bool */) = tvm.rawConfigParam(16);
        (uint16 max_validators, /* uint16 */, uint16 min_validators) = cfg16.toSlice().decode(uint16, uint16, uint16);
        min_validators = math.max(min_validators, 1);
        uint16 n = 0;
        mapping(Key => Value) sdict;
        mapping(uint256 => Member) members = m_chains[chainId].election.members;
        for ((uint256 pkey, Member _mem) : members) {
            (uint128 stake, uint32 time, uint32 max_factor, uint256 addr, uint256 adnl_addr) = _mem.unpack();
            sdict[Key(stake, -int32(time), pkey)] =
                Value(math.min(max_factor, max_stake_factor), addr, adnl_addr);
            ++n;
        }
        n = math.min(n, max_validators);
        if (n < min_validators) {
            mapping(uint16 => TvmSlice) nil1;
            mapping(uint256 => Frozen) nil2;
            return (nil1, 0, nil2, 0, 0);
        }
        optional(List) l;
        for ((Key key, Value value) : sdict) {
            uint128 stake = math.min(key.stake, max_stake);
            l = List({
                stake: stake,
                max_f: value.max_f,
                pubkey: key.pubkey,
                adnl_addr: value.adnl_addr,
                tail: l
            });
        }

        // l is the list of all stakes in decreasing order
        uint128 m_stake = 0; // minimal stake
        uint128 best_stake = 0;
        uint16 m = 0;
        optional(List) l1 = l;

        uint128 wholeStakeSum = 0;
        mapping(EdgeStake => StakeAndFactor) wholeStakes;
        uint128 cutFactSum = 0;

        for (uint16 qty = 1; qty <= n; ++qty) {
            List list1 = l1.get();
            uint128 stake = list1.stake;
            if (stake < min_stake) {
                break;
            }
            uint32 max_f = list1.max_f;
            l1 = list1.tail;

            wholeStakeSum += stake;
            uint256 edgeStake = (uint256(stake) * uint256(65536) * PRECISION) / max_f; // 128+16+64-32
            wholeStakes[EdgeStake(edgeStake, qty)] = StakeAndFactor(stake, max_f);

            while (!wholeStakes.empty()) {
                (EdgeStake es, StakeAndFactor sf) = wholeStakes.max().get();
                if (es.stake < stake * PRECISION) {
                    break;
                }
                wholeStakeSum -= sf.stake;
                wholeStakes.delMax();
                cutFactSum += sf.max_f;
            }

            uint128 sum_stake = wholeStakeSum + uint128((uint256(stake) * cutFactSum) >> 16);
            if ((qty == min_validators) || (sum_stake > best_stake)) {
                best_stake = sum_stake;
                m = qty;
                m_stake = stake;
            }
        }

        if ((m == 0) || (best_stake < min_total_stake)) {
            mapping(uint16 => TvmSlice) nil1;
            mapping(uint256 => Frozen) nil2;
            return (nil1, 0, nil2, 0, 0);
        }
        // we have to select first m validators from list l

        // precise calculation of best stake
        {
            uint128 round_best_stake = best_stake;
            best_stake = 0;
            l1 = l;
            repeat(m) {
                List list1 = l1.get();
                best_stake += math.min(list1.stake, m_stake * list1.max_f >> 16);
                l1 = list1.tail;
            }
            require(math.abs(int(round_best_stake) - int(best_stake)) <= 1 ever, 666);
        }

        // create both the new validator set and the refund set
        uint16 i = 0;
        uint128 tot_stake = 0;
        uint128 tot_weight = 0;
        mapping(uint16 => TvmSlice) vset;
        mapping(uint256 => Frozen) frozen;
        mapping(uint256 => varUint16) credits = m_credits;
        do {
            (uint128 stake, uint32 max_f, uint256 pubkey, uint256 adnl_addr, optional(List) tail) = l.get().unpack();
            l = tail;
            // lookup source address first
            optional(Member) mem = members.fetch(pubkey);
            require(mem.hasValue(), 61);
            uint256 src_addr = mem.get().addr;
            if (i < m) {
                // one of the first m members, include into validator set
                uint128 true_stake = math.min(stake, (max_f * m_stake) >> 16);
                stake -= true_stake;
                uint128 weight = (true_stake << 60) / best_stake;
                tot_stake += true_stake;
                tot_weight += weight;
                TvmBuilder vinfo;
                if (adnl_addr > 0) {
                    vinfo.store(Common.ValidatorAddr(0x73, 0x8e81278a, pubkey,
                                                     uint64(weight), adnl_addr));
                } else {
                    vinfo.store(Common.Validator(0x53, 0x8e81278a, pubkey,
                                                 uint64(weight)));
                }
                vset[i] = vinfo.toSlice();
                frozen[pubkey] = Frozen(src_addr, uint64(weight), varUint16(true_stake), false);
            }
            if (stake > 0) {
                // non-zero unused part of the stake, credit to the source address
                // credit_to(src_addr, stake);
                credits[src_addr] += varUint16(stake);
            }
            i += 1;
        } while (l.hasValue());
        m_credits = credits;
        require(tot_stake == best_stake, 49);
        return (vset, uint64(tot_weight), frozen, tot_stake, m);
    }

    function conduct_elections(int32 chainId) internal returns (bool) {
        Elect cur_elect = m_chains[chainId].election;
        if (now < cur_elect.elect_close) {
            // elections not finished yet
            return false;
        }
        (/* TvmCell */, bool f) = tvm.rawConfigParam(0);
        if (!f) {
            // no configuration smart contract to send result to
            return postpone_elections(1);
        }
        (uint128 min_stake, uint128 max_stake, uint128 min_total_stake,
          uint32 max_stake_factor, /* bool */) = tvm.configParam(17);
        if (cur_elect.total_stake < min_total_stake) {
            // insufficient total stake, postpone elections
            return postpone_elections(2);
        }
        if (cur_elect.failed) {
            // do not retry failed elections until new stakes arrive
            return postpone_elections(3);
        }
        if (cur_elect.finished) {
            // elections finished
            return false;
        }
        (mapping(uint16 => TvmSlice) vdict, uint64 total_weight,
         mapping(uint256 => Frozen) frozen, uint128 total_stakes, uint16 cnt) =
            try_elect(
                min_stake,
                max_stake,
                min_total_stake,
                max_stake_factor,
                chainId
            );
        // pack elections; if cnt==0, set failed=true, finished=false.
        cur_elect.failed = (cnt == 0);
        cur_elect.finished = !cur_elect.failed;
        m_chains[chainId].election = cur_elect;
        if (cnt == 0) {
            // elections failed, set elect_failed to true
            return postpone_elections(4);
        }
        uint32 cur_elect_at = cur_elect.elect_at;
        // serialize a query to the configuration smart contract
        // to install the computed validator set as the next validator set
        (uint32 elect_for, /* uint32 */, uint32 elect_end_before, uint32 stake_held) =
            get_validator_conf();
        uint32 start = math.max(now + elect_end_before - 60, cur_elect_at);


        Common.ValidatorSet vset = Common.ValidatorSet({
            tag:uint8(0x12),
            utime_since: start,
            utime_until: start + elect_for,
            total: cnt,
            total_weight: total_weight,
            vdict: vdict
        });

        TvmBuilder b;
        b.store(vset);
        TvmCell vsetCell = b.toCell();

        (TvmCell cfg0, /* bool */) = tvm.rawConfigParam(0);
        uint256 config_addr = cfg0.toSlice().loadUnsigned(256);
        send_validator_set_to_config(config_addr, vsetCell, cur_elect_at, chainId);
        // add frozen to the dictionary of past elections
        PastElection past;
        past.unfreeze_at = start + elect_for + stake_held;
        past.stake_held = stake_held;
        past.vset_hash = tvm.hash(vsetCell);
        past.frozen_dict = frozen;
        past.total_stake = varUint16(total_stakes);
        m_chains[chainId].past_elections[cur_elect_at] = past;
        // reset slasher
        mapping(uint256 => bool) nil1;
        m_banned = nil1;
        mapping(uint256 => mapping(uint8 => Bucket)) nil2;
        m_reports = nil2;

        uint64 vtors_weight = 0;
        for((, TvmSlice entry) : vdict) {
            (,, uint64 weight) = decode_validator(entry);
                vtors_weight += weight;
        }
        m_chains[chainId].vtors_weight = vtors_weight;

        return true;
    }

    function update_active_vset_id(int32 chainId) internal returns (bool) {

        (optional(Common.ValidatorSets) may_be_vsets)  = Common.getValidatorSetsByChain(chainId);

        if (!may_be_vsets.hasValue() ) {
            // can't decode config 100
            return false;
        }
        if  (!may_be_vsets.get().current.hasValue()) {
            return false;

        }
        Common.ValidatorSet vset = may_be_vsets.get().current.get();

        TvmBuilder v;
        v.store(vset);
        Elect election = m_chains[chainId].election;

        uint256 cur_hash = tvm.hash(v.toCell());
        if (cur_hash == m_chains[chainId].active_hash) {
            // validator set unchanged
            return false;
        }

        uint32 active_id = m_chains[chainId].active_id;
        if (active_id != 0) {
            // active_id becomes inactive

            optional(PastElection) p_opt = m_chains[chainId].past_elections.fetch(active_id);
            if (p_opt.hasValue()) {
                PastElection past = p_opt.get();
                // adjust unfreeze time of this validator set
                require(past.vset_hash == m_chains[chainId].active_hash, 57);
                past.unfreeze_at = now + past.stake_held;

                m_chains[chainId].past_elections[active_id] = past;
            }
        }
        // look up new active_id by hash

        optional(uint32, PastElection) p = m_chains[chainId].past_elections.min();
        while (p.hasValue()) {
            (uint32 id, PastElection past) = p.get();
            if (past.vset_hash == cur_hash) {
                // transfer 1/8 of accumulated everybody's grams to this validator set as bonuses
                uint128 amount = (m_grams >> 3);
                m_grams -= varUint16(amount);
                past.bonuses += varUint16(amount);

                m_chains[chainId].past_elections[id] = past;
                // found
                break;
            }

            p = m_chains[chainId].past_elections.next(id);
        }

        if (p.hasValue()) {
            (uint32 id, ) = p.get();
            m_chains[chainId].active_id = id;
        } else {
            m_chains[chainId].active_id = 0;
        }
        m_chains[chainId].active_hash = cur_hash;
        return true;
    }

    function validator_set_installed(int32 chainId) internal returns (bool) {
        if (!m_chains[chainId].election.finished) {
            // elections not finished yet
            return false;
        }

        optional(PastElection) p = m_chains[chainId].past_elections.fetch(m_chains[chainId].election.elect_at);
        if (!p.hasValue()) {
            // no election data in dictionary
            return false;
        }
        PastElection past = p.get();

        optional(Common.ValidatorSets) vsets = Common.getValidatorSetsByChain(chainId);
        if (!vsets.hasValue()) {
            // can't decode config 100 or config doesn't include particular `chainId`
            return false;
        }
        Common.ValidatorSets chainSet = vsets.get();

        TvmBuilder currentSetHash;
        if  (chainSet.current.hasValue()) {
            currentSetHash.store(chainSet.current.get());
        }

        TvmBuilder nextSetHash;
        if  (chainSet.next.hasValue()) {
            nextSetHash.store(chainSet.next.get());
        }
        // recover validator set hash

        if ((chainSet.current.hasValue() && (tvm.hash(currentSetHash.toCell()) == past.vset_hash)) ||
            (chainSet.next.hasValue() && (tvm.hash(nextSetHash.toCell()) == past.vset_hash))) {
            // this validator set has been installed, forget elections
            m_chains[chainId].election.open = false;
            Elect elect;
            m_chains[chainId].election = elect;
            update_active_vset_id(chainId);
            return true;
        }
        return false;
    }

    function check_unfreeze(int32 chainId) internal {

        optional(uint32, PastElection) p = m_chains[chainId].past_elections.min();
        while (p.hasValue()) {
            (uint32 id, PastElection past) = p.get();

            if ((past.unfreeze_at <= now) && (id != m_chains[chainId].active_id)) {
                // unfreeze!
                m_grams += varUint16(unfreeze_all(id,chainId));
                // unfreeze only one at time, exit loop
                break;
            }
            p = m_chains[chainId].past_elections.next(id);
        }
    }

    function announce_new_elections(int32 chainId) internal returns (bool) {

        optional(Common.ValidatorSets) may_be_vsets = Common.getValidatorSetsByChain(chainId);

        if (!may_be_vsets.hasValue()) {
            return false;
        }
        Common.ValidatorSets vsets = may_be_vsets.get();
        if (vsets.next.hasValue()) {
            // next validator set exists, no elections needed
            return false;
        }
        (TvmCell cfg1, /* bool */) = tvm.rawConfigParam(1);
        uint256 elector_addr = cfg1.toSlice().loadUnsigned(256);
        (int8 my_wc, uint256 my_addr) = address(this).unpack();
        if ((my_wc != -1) || (my_addr != elector_addr)) {
            // this smart contract is not the elections smart contract anymore, no new elections
            return false;
        }
        optional(Common.ValidatorSet) cur_vset = vsets.current;

        if (!cur_vset.hasValue()) {
            return false;
        }

        (/* uint32 */, uint32 elect_begin_before, uint32 elect_end_before, /* uint32 */) = get_validator_conf();
        uint32 cur_valid_until = cur_vset.get().utime_until;

        uint32 t = now;
        uint32 t0 = cur_valid_until - elect_begin_before;
        if (t < t0) {
            // too early for the next elections
            return false;
        }
        // less than elect_before_begin seconds left, create new elections
        if (t - t0 < 60) {
            // pretend that the elections started at t0
            t = t0;
        }
        // get stake parameters
        (uint128 min_stake, /* uint128 */, /* uint128 */, /* uint32 */, /* bool */) = tvm.configParam(17);
        // announce new elections
        uint32 elect_at = t + elect_begin_before;
        // elect_at~dump();
        uint32 elect_close = elect_at - elect_end_before;

        TvmCell e;
        Elect n_elect = Elect({
            elect_at: elect_at,
            elect_close: elect_close,
            min_stake: varUint16(min_stake),
            total_stake: 0,
            members: emptyMap,
            failed: false,
            finished: false,
            open: true
        });
        m_chains[chainId].election = n_elect;
        return true;
    }

    onTickTock(bool /* is_tock */) external {
        for ((int32 chainId, Chain chain) : m_chains) {
        // check whether an election is being conducted
            if (chain.election.open) {
                // have an active election
                if (conduct_elections(chainId)) {
                    // todo handle if consensus success
                    // elections conducted, exit
                    return;
                }
                if (validator_set_installed(chainId)) {
                    // validator set installed, current elections removed
                    return;
                }
            } else {
                if (announce_new_elections(chainId)) {
                    // new elections announced, exit
                    return;
                }
            }
            if (update_active_vset_id(chainId)) {
                // active validator set id updated, exit
                return;
            }
            check_unfreeze(chainId);
        }

    }

    uint8 constant BAD_CONFIG_PARAM_1      = 130;
    uint8 constant BAD_CONFIG_PARAM_34     = 131;
    uint8 constant BAD_REPORTER_PUBKEY     = 132;
    uint8 constant BAD_VICTIM_PUBKEY       = 133;
    uint8 constant BAD_SIGNATURE           = 134;
    uint8 constant BAD_REPORTER_WEIGHT     = 135;
    uint8 constant BAD_ACTIVE_ID           = 136;
    uint8 constant BAD_BANNED_REPORTER     = 137;
    uint8 constant BAD_BANNED_VICTIM       = 138;
    uint8 constant BAD_REPORT_TIME         = 139;
    uint8 constant BAD_REPORT_DUPLICATE    = 140;
    uint8 constant BAD_TOTAL_VTORS         = 141;

    mapping(uint256 => bool) m_banned;

    struct Bucket {
        uint64 weight;
        mapping(uint256 => uint64) reports;
    }

    mapping(uint256 => mapping(uint8 => Bucket)) m_reports;
    uint64 constant THRESHOLD_NUMERATOR   = 2;
    uint64 constant THRESHOLD_DENOMINATOR = 3;



    function require_ok(bool condition, uint errorCode) internal inline {
        if (!condition) {
            tvm.commit();
            revert(errorCode);
        }
    }

    function decode_validator(TvmSlice entry) internal inline pure returns (uint8, uint256, uint64) {
        uint8 tag = entry.decode(uint8);
        require(tag == 0x53 || tag == 0x73, BAD_CONFIG_PARAM_34);
        (uint32 ed25519_pubkey, uint256 pubkey, uint64 weight) = entry.decode(uint32, uint256, uint64);
        require(ed25519_pubkey == 0x8e81278a, BAD_CONFIG_PARAM_34);
        return (tag, pubkey, weight);
    }

    function report(
        uint256 signature_hi,
        uint256 signature_lo,
        uint256 reporter_pubkey,
        uint256 victim_pubkey,
        uint8 metric_id,
        int32 chainId
    ) public externalMsg {
        Common.ValidatorSet vset = get_current_vset(chainId);
        require(vset.tag == 0x12, BAD_CONFIG_PARAM_34);

        // ignore reports outside of the vset's active time interval
        require(vset.utime_since < now && now < vset.utime_until, BAD_REPORT_TIME);

        TvmBuilder signature;
        signature.store(signature_hi, signature_lo);
        TvmBuilder msg_body;
        msg_body.store(reporter_pubkey, victim_pubkey, metric_id);

        // accept external message
        tvm.accept();
        require(tvm.checkSign(msg_body.toSlice(), signature.toSlice(), reporter_pubkey), 34);

        // ignore reports from already banned reporters
        require_ok(!m_banned.exists(reporter_pubkey), BAD_BANNED_REPORTER);

        // ignore reports about already banned reportees
        require_ok(!m_banned.exists(victim_pubkey), BAD_BANNED_VICTIM);

        // find reporter's descriptor and its index 
        uint64 reporter_weight = 0;
        uint16 reporter_index = 0;
        for((, TvmSlice entry) : vset.vdict) {
            (, uint256 pubkey, uint64 weight) = decode_validator(entry);
            if (pubkey == reporter_pubkey) {
                reporter_weight = weight;
                break;
            }
            reporter_index += 1;
        }
        require(reporter_weight > 0, BAD_REPORTER_WEIGHT);

        // find victim's descriptor
        uint16 victim_index = 0;
        bool victim_found = false;
        for((, TvmSlice entry) : vset.vdict) {
            (, uint256 pubkey,) = decode_validator(entry);
            if (pubkey == victim_pubkey) {
                victim_found = true;
                break;
            }
            victim_index += 1;
        }
        require(victim_found, BAD_VICTIM_PUBKEY);

        (TvmCell cfg16, ) = tvm.rawConfigParam(16);
        ( , , uint16 min_validators) = cfg16.toSlice().decode(uint16, uint16, uint16);

        // TODO what is the metric_id ?
        Bucket bucket = m_reports[victim_pubkey][metric_id];
        optional(uint64) exists = bucket.reports.fetch(reporter_pubkey);
        // proceed only if the reporter hasn't yet reported
        require_ok(!exists.hasValue(), BAD_REPORT_DUPLICATE);

        bucket.weight += reporter_weight;
        bucket.reports[reporter_pubkey] = reporter_weight;
        m_reports[victim_pubkey][metric_id] = bucket;
        tvm.commit();



        if (bucket.weight >= math.muldiv(m_chains[chainId].vtors_weight, THRESHOLD_NUMERATOR, THRESHOLD_DENOMINATOR)) {
            // slashing condition is met
            // TODO fix it after understanding metric_id
//            require(vset.vdict.keys().length > min_validators, BAD_TOTAL_VTORS);
            m_banned[victim_pubkey] = true;
            emit_updated_validator_set(victim_pubkey, victim_index, chainId);
        }
    }

    function update_reports(uint256 victim_pubkey, mapping(uint256 => mapping(uint8 => Bucket)) reports) internal pure
        returns (mapping(uint256 => mapping(uint8 => Bucket))) {
        mapping(uint256 => mapping(uint8 => Bucket)) new_reports = reports;
        for ((uint256 key, mapping(uint8 => Bucket) buckets) : reports) {
            for((uint8 id, Bucket bucket) : buckets) {
                for((uint256 public_key, uint64 weight) : bucket.reports) {
                    if (victim_pubkey == public_key) {
                        bucket.weight -= weight;
                        delete bucket.reports[victim_pubkey];
                        mapping(uint8 => Bucket) new_buckets = buckets;
                        new_buckets[id] = bucket;
                        new_reports[key] = new_buckets;
                        break;
                    }
                }
            }
        }
        return new_reports;
    }

    function emit_updated_validator_set(
        uint256 victim_pubkey,
        uint16 victim_index,
        int32 chainId
    ) internal inline {
        Common.ValidatorSet vset = get_current_vset(chainId);
        mapping(uint16 => TvmSlice) vdict = vset.vdict;
        uint64 total_weight;

        (TvmCell p16, ) = tvm.rawConfigParam(16);
        (, , uint16 min_validators) = p16.toSlice().decode(uint16, uint16, uint16);
        require(vset.total > min_validators, BAD_TOTAL_VTORS);

        bool loop = false;
        uint16 index = 0;
        do {
            // remove all claims of banned validator
            if (victim_index < min_validators) {
                min_validators -= 1;
                m_reports = update_reports(victim_pubkey, m_reports);
            } else {
                m_reports = update_reports(victim_pubkey, m_reports);
            }

            mapping(uint16 => TvmSlice) vdict_updated = emptyMap;

            total_weight = 0;

            for((, TvmSlice entry) : vdict) {
                TvmSlice entryRead = entry;
                (, uint256 pubkey, uint64 weight) = decode_validator(entryRead);
                if (!m_banned.exists(pubkey)) {
                        vdict_updated[index] = entry;
                        total_weight += weight;
                        index += 1;
                }
            }
            require(index >= min_validators, BAD_TOTAL_VTORS);


            m_chains[chainId].vtors_weight = total_weight;
            index = 0;


            mapping(uint256 => mapping(uint8 => Bucket)) reports = m_reports;
            uint128 max_weight = math.muldiv(m_chains[chainId].vtors_weight, THRESHOLD_NUMERATOR, THRESHOLD_DENOMINATOR);
            for((, TvmSlice entry) : vdict_updated) {
                Common.ValidatorAddr vtor = entry.decode(Common.ValidatorAddr);
                require(vtor.tag != 0x53, BAD_CONFIG_PARAM_34);
                optional(mapping(uint8 => Bucket)) buckets = reports[vtor.pubkey];
                if (buckets.hasValue()) {
                    for((, Bucket bucket) : buckets.get()) {
                        // this validator becomes slashed
                        if (bucket.weight >= max_weight) {
                            m_banned[vtor.pubkey] = true;
                            loop = true;
                            victim_pubkey = vtor.pubkey;
                            victim_index = index;
                            vdict = vdict_updated;
                            break;
                        }
                    }
                }
                if (loop) {
                    continue;
                }
                index += 1;
            }
            vdict = vdict_updated;
        } while(loop);

        Common.ValidatorSet vset_updated;
        vset_updated.tag          = 0x12;
        vset_updated.utime_since  = now + 60; // allow 1 minute to receive slashed set in config
        vset_updated.utime_until  = vset.utime_until;
        vset_updated.total_weight = total_weight;
        vset_updated.total        = index;
        vset_updated.vdict        = vdict;

        TvmBuilder b;
        b.store(vset_updated);
        TvmCell vset_updated_cell = b.toCell();

        uint32 active_id = m_chains[chainId].active_id;
        optional(PastElection) p = m_chains[chainId].past_elections.fetch(active_id);
        require(p.hasValue(), BAD_ACTIVE_ID);
        PastElection past = p.get();

        uint256 active_hash = tvm.hash(vset_updated_cell);
        m_chains[chainId].active_hash = active_hash;
        past.vset_hash = active_hash;
        optional(Frozen) f = past.frozen_dict.fetch(victim_pubkey);
        if (f.hasValue()) {
            Frozen frozen = f.get();
            frozen.banned = true;
            past.frozen_dict[victim_pubkey] = frozen;
            past.bonuses += frozen.stake;
            past.total_stake -= frozen.stake;
        }


        m_chains[chainId].past_elections[active_id] = past;
        (TvmCell cfg0, ) = tvm.rawConfigParam(0);
        address config_addr = address.makeAddrStd(-1, cfg0.toSlice().loadUnsigned(256));
        IConfig(config_addr).set_slashed_validator_set{
                value: (1 << 30),
                flag: 1
        }(active_id, vset_updated_cell, chainId);
    }

    // Get complete storage
    function get() public view
        returns (
            mapping(int32 => Chain) chains,
            uint128 grams
        )
    {
        chains = m_chains;
        grams = m_grams;
    }

    function get_banned() public view returns (mapping(uint256 => bool)) {
        return m_banned;
    }

    function get_buckets(uint256 victim_pubkey) public view returns (mapping(uint8 => Bucket)) {
        return m_reports[victim_pubkey];
    }

//    function get_buckets_workchain(uint256 victim_pubkey) public view returns (mapping(uint8 => Bucket)) {
//        return m_reports_workchain[victim_pubkey];
//    }

    // returns active election id or 0
    function active_election_id(int32 chainId) public view returns (uint32) {
        return m_chains[chainId].election.open ? m_chains[chainId].election.elect_at : 0;
    }

    // returns version of elector (major, minor)
    function get_version() public pure returns (uint32, uint32) {
        return (VERSION_MAJOR, VERSION_MINOR);
    }

    // computes the return stake
    function compute_returned_stake(uint256 wallet_addr) public view returns (uint256) {
        optional(uint128) v = m_credits.fetch(wallet_addr);
        return v.hasValue() ? v.get() : 0;
    }

    onBounce(TvmSlice slice) external {
        uint32 id = slice.decode(uint32);
        if (id == tvm.functionId(IValidator.receive_stake_back)) {
            (int8 src_wc, uint256 src_addr) = msg.sender.unpack();
            require(src_wc == -1, 223);
            m_credits[src_addr] = varUint16(msg.value);
        }
    }

    receive() external {
        // inbound message has empty body
        // simple transfer with comment, return
        process_simple_transfer();
    }

    fallback() external pure {
        TvmSlice s = msg.data;
        uint32 op = s.loadUnsigned(32);
        uint64 query_id = s.loadUnsigned(64);
        send_message_back(msg.sender, 0xffffffff, query_id, op, 0, 64);
    }

    function onCodeUpgrade(address s_addr, TvmSlice /*data*/, uint64 query_id) internal pure functionID(2) {
        send_message_back(s_addr, 0xce436f64, query_id, 0x4e436f64, 0, 64);
        tvm.exit();
    }

    function _upgrade_code(uint64 query_id, TvmCell code, TvmCell data) internal pure returns (bool) {
        (TvmCell c_addr, bool f) = tvm.rawConfigParam(0);
        if (!f) {
            // no configuration smart contract known
            return false;
        }
        address s_addr = msg.sender;
        uint256 config_addr = c_addr.toSlice().loadUnsigned(256);
        (int8 src_wc, uint256 src_addr) = msg.sender.unpack();
        if (src_wc != -1 || src_addr != config_addr) {
            // not from configuration smart contract, return error
            return false;
        }
        tvm.accept();
        tvm.setcode(code);
        tvm.setCurrentCode(code);
        onCodeUpgrade(s_addr, data.toSlice(), query_id);
    }

    function upgrade_code(uint64 query_id, TvmCell code, TvmCell data) override public
            functionID(0x4e436f64) internalMsg {
        bool ok = _upgrade_code(query_id, code, data);
        send_message_back(msg.sender, ok ? 0xce436f64 : 0xffffffff, query_id, 0x4e436f64, 0, 64);
    }
}
